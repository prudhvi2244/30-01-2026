Date : 30-01-2026
==========================
Topics : 
=====================
1)StringBuffer
2)StringBuilder
3)Collection Framework
4)Generics
5)Functional InterfaceName
6)Lambda Expressions

StringBuffer:
========================
1)If we want to create String Objects which are mutable
2)StringBuffer will not create new String objects everytime whenever object is modified
3)All methods present inside StringBuffer are synchronized
4)Useful in multi-threading applications


String s="Prudhvi";

String s11=s.concat("Raj")

println(s)


StringBuilder(java 5):
==========================
1)Introduced in Java 5
2)IF we don't want thread safety and if we want string objects to be mutable then prefer StringBuilder
3)All methods present inside StringBuilder are not synchronized

Collection Framework:
============================
1)If we want to represent group of individual objects then we can use Collection Framework
2)We can Represent Heterogeneous Objects
3)Collections are given to work with objects only not primitive types
4)They are Growable in Nature

Important interfaces in Collection Framework:
=================================================
1)List
2)Set
3)Map
4)Queue

** Collection is the Parent interface for all Collections in Java

List(I):
===================
1)If we want to Represent group of individual objects then we can use List
2)Duplicate objects allowed
3)Insertion Order Preserved
4)null insertion is possible
5)Follows Index Based Approach
6)List is the child interface of Collection(I)

There are 4 Child Classes of List:
=====================================
1)ArrayList(C)
2)LinkedList(C)
3)Vector(C)
    4)Stack(C)


ArrayList (C):
======================
1)The Underlying D.S is Re-Sizable or Growable Array
2)Insertion Order is Preserved
3)duplicate objects allowed
4)null insertion is possible
5)Heterogeneous objects are allowed
6)It is the child class of List interface

important methods of Collection(I):
==========================================
1)public abstract int size()
2)public abstract boolean isEmpty()
3)public abstract boolean contains(java.lang.Object)
4)public abstract void clear()
5)public abstract boolean add(E)
6)public abstract java.lang.Object[] toArray()
7)public abstract java.util.Iterator<E> iterator();
8)public abstract boolean remove(java.lang.Object);
9)public default java.util.stream.Stream<E> stream();

ArrayList Constructors:
==============================
1)public java.util.ArrayList(int capacity) : Creates an empty ArrayList object with specified initial capacity
2)public java.util.ArrayList() : Creates an empty ArrayList object with default initial capacity
3)public java.util.ArrayList(java.util.Collection<? extends E>) : Creates an empty ArrayList object for given Collection Object


LinkedList:
=======================
1)Child class of List Interface
2)Underlying  D.S is doubly linked list
3)null=>ref to prev element=>data=>ref to next element
4)insertion order preserved
5)duplicate objects allowed
6)null insertion is possible
7)Heterogeneous objects are allowed
8)If our Frequent operations are Insertion or Deletions in between then LinkedList is best
suitable

Vector(C):
==================
1)Child class of List Interface
2)Underlying  D.S is Growable or Re-Sizable Array
3)insertion order preserved
4)duplicate objects allowed
5)null insertion is possible
6)Heterogeneous objects are allowed
7)If our Frequent operations are Retrieval Operations and we need thread safety then go for vector class object
8)all methods present in vector class are synchronized
9)Introduced in java 1.0v

Stack(C):
======================
1)It is the child class of Vector introduced in java 1.0v
2)Follows LIFO


Set(I):
================
1)It is the child interface of Collection(I)
2)If we want to represent group of individual objects where duplicate objects are not
 allowed then we can go for Set Interface
3)Insertion Order is not preserved
4)null insertion is possible
5)Heterogeneous objects are allowed
6)Commonly used Child Classes of Set Interface are
   i)HashSet
   ii)LinkedHashSet
   iii)TreeSet

HashSet(C):
=======================
1)Child class of Set Interface
2)Underlying D.S is Hashing (HashTable)
3)Insertion Order is not preserved
4)duplicate objects are not allowed
5)null insertion is possible
6)Heterogeneous objects are allowed
7)If we want high performance and we don't want thread safety then go for HashSet class object

LinkedHashSet(C):
=============================
1)It is the child class of HashSet
2)Underlying D.S is Hashing(Hashtable) + Doubly Linked List
3)Insertion Order is preserved
4)duplicate objects are not allowed
5)null insertion is possible
6)Heterogeneous objects are allowed
7)If we want high performance with insertion order preserved and we don't want thread safety then go for LinkedHashSet class object

TreeSet(C):
=============================
1)Child class of Set Interface
2)Underlying D.S is Balanced Tree(Red-Black Tree)
3)Insertion Order is not preserved but it will sort the objects in natural sorting order
4)duplicate objects are not allowed
5)null insertion is not possible(NullPointerException)
6)Heterogeneous objects are not allowed (Homogeneous objects only)(ClassCastException)
7)If we want to represent group of individual objects in sorted order then go for TreeSet class object

constructors of TreeSet:
=============================
1)public java.util.TreeSet() : creates empty TreeSet object which will sort objects in natural sorting order
2)public java.util.TreeSet(java.util.Comparator<? super E> comparator) : creates empty TreeSet object which will sort objects based on custom sorting order provided by Comparator Object
3)public java.util.TreeSet(java.util.Collection<? extends E> c) : creates TreeSet object containing all elements from the given Collection object and sorts them in natural sorting order
4)public java.util.TreeSet(java.util.SortedSet<E> s) : creates TreeSet object containing all elements from the given SortedSet object and sorts them in natural sorting order


Comparable(I):
=============================
1)If we want to sort objects in natural sorting order then we can go for Comparable Interface
2)It contains only one method
   i)public abstract int compareTo(java.lang.Object o)

3)We need to override compareTo method to provide natural sorting order logic

compareTo method returns negative integer, zero, positive integer

obj1.compareTo(obj2)

obj1 : already present object
obj2 : newly added object

Returns Negative integer : if obj1 < obj2
Returns Positive integer : if obj1 > obj2
Returns Zero : if obj1 == obj2

10.compareTo(20) => -ve integer (obj1<obj2)
20.compareTo(10) => +ve integer (obj1>obj2)
10.compareTo(10) => 0 (obj1==obj2)

Comparator(I):
=============================
1)It is from java.util package
2)If we want to sort objects in custom sorting order then we can go for Comparator Interface
3)It contains one methods
   i)public abstract int compare(java.lang.Object o1, java.lang.Object o2)

4)We need to override compare method to provide custom sorting order logic
5)compare method returns negative integer, zero, positive integer

Returns Negative integer : if obj1 < obj2
Returns Positive integer : if obj1 > obj2
Returns Zero : if obj1 == obj2



